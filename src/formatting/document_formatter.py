"""Professional document formatting utilities used across the Graive system.

This module is responsible for taking the rich markdown generated by the
planning/execution pipeline and producing polished deliverables. Besides the
enhanced markdown artefacts that were previously generated, the formatter now
creates fully fledged DOCX and PDF documents with rich styling, inline
formatting (bold/italics/code), embedded tables, and synthesised figures.

Images are procedurally generated with Pillow so the final files never contain
missing placeholders, and every markdown export automatically produces DOCX and
PDF companions. These guarantees keep the user deliverables consistent no
matter which output format was originally requested.
"""

from __future__ import annotations

import re
import base64
import textwrap
import zipfile
import zlib
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import html

try:
    from markdown import markdown as md_to_html

    MARKDOWN_AVAILABLE = True
except ImportError:  # pragma: no cover - handled gracefully at runtime
    MARKDOWN_AVAILABLE = False

    def md_to_html(text: str, extensions: Optional[List[str]] = None) -> str:
        """Minimal fallback that wraps the markdown in a <pre> block."""

        escaped = html.escape(text)
        return f"<pre>{escaped}</pre>"

try:
    from docx import Document
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    from docx.shared import Inches

    DOCX_AVAILABLE = True
except ImportError:  # pragma: no cover - handled gracefully at runtime
    DOCX_AVAILABLE = False

try:
    from fpdf import FPDF, HTMLMixin

    class _PDFDocument(FPDF, HTMLMixin):
        """Helper PDF class with HTML rendering support."""

    PDF_AVAILABLE = True
except ImportError:  # pragma: no cover - handled gracefully at runtime
    PDF_AVAILABLE = False

try:
    from PIL import Image, ImageDraw, ImageFont

    PIL_AVAILABLE = True
except ImportError:  # pragma: no cover - handled gracefully at runtime
    PIL_AVAILABLE = False

MINIMAL_PNG_BYTES = (
    b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x06\x00"
    b"\x00\x00\x1f\x15\xc4\x89\x00\x00\x00\x0bIDATx\x9cc```\x00\x00\x00\x04\x00\x01"
    b"\r\n-\xb4\x00\x00\x00\x00IEND\xaeB`\x82"
)

PNG_SIGNATURE = b"\x89PNG\r\n\x1a\n"


@dataclass
class ImageSpec:
    """Specification for document image."""

    caption: str
    description: str
    width: int = 600
    height: int = 400
    position: str = "center"


@dataclass
class TableSpec:
    """Specification for document table."""

    title: str
    headers: List[str]
    rows: List[List[str]]
    caption: Optional[str] = None


class ProfessionalDocumentFormatter:
    """Creates professionally formatted academic documents."""

    def __init__(self, workspace_path: str):
        self.workspace = Path(workspace_path)
        self.images_dir = self.workspace / "images"
        self.documents_dir = self.workspace / "documents"

        self.images_dir.mkdir(parents=True, exist_ok=True)
        self.documents_dir.mkdir(parents=True, exist_ok=True)

    def format_document(
        self,
        content: str,
        title: str,
        author: str = "Graive AI",
        output_format: str = "docx",
        include_toc: bool = True,
        include_page_numbers: bool = True,
    ) -> Dict[str, Any]:
        """Format markdown content into professional deliverables."""

        print(f"\n{'=' * 70}")
        print("📄 PROFESSIONAL DOCUMENT FORMATTING")
        print(f"{'=' * 70}")
        print(f"Title: {title}")
        print(f"Requested Primary Format: {output_format.upper()}")
        print(f"{'=' * 70}\n")

        # Stage 1: Parse markdown
        print("[1/6] Parsing document structure...")
        parsed = self._parse_markdown_structure(content)
        print(
            "      Found: "
            f"{len(parsed['headings'])} sections, "
            f"{len(parsed['images'])} images, "
            f"{len(parsed['tables'])} tables"
        )

        # Stage 2: Generate actual image assets
        print("\n[2/6] Generating images...")
        generated_images, image_replacements = self._generate_images(parsed["images"], title)
        print(f"      Generated {len(generated_images)} images")

        # Stage 3: Prepare tables
        print("\n[3/6] Formatting tables...")
        formatted_tables = self._format_tables(parsed["tables"])
        print(f"      Formatted {len(formatted_tables)} tables")

        # Stage 4: Apply styling + replace references
        print("\n[4/6] Applying professional styling...")
        styled_content = self._apply_styling(content, parsed, image_replacements)

        # Stage 5: Always emit enhanced markdown companion
        print("\n[5/6] Creating enhanced markdown artefact...")
        markdown_path = self._export_document(
            styled_content,
            title,
            author,
            "md",
            generated_images,
            formatted_tables,
            include_toc,
            include_page_numbers,
        )

        # Stage 6: Produce requested + guaranteed formats
        print("\n[6/6] Exporting deliverables...")
        export_formats = {output_format.lower(), "docx", "pdf"}
        export_results: Dict[str, Optional[str]] = {"md": markdown_path}
        for fmt in sorted(export_formats):
            export_results[fmt] = self._export_document(
                styled_content,
                title,
                author,
                fmt,
                generated_images,
                formatted_tables,
                include_toc,
                include_page_numbers,
            )

        primary_path = export_results.get(output_format.lower()) or markdown_path

        print(f"\n{'=' * 70}")
        print("✅ DOCUMENT FORMATTED SUCCESSFULLY")
        print(f"{'=' * 70}")
        print(f"📄 Primary File: {Path(primary_path).name}")
        print(f"📍 Location: {primary_path}")
        print("📦 Exports:")
        for fmt, path in export_results.items():
            if path:
                print(f"   • {fmt.upper()}: {path}")
        print(f"🖼️  Images: {len(generated_images)}")
        print(f"📈 Tables: {len(formatted_tables)}")
        print(f"{'=' * 70}\n")

        return {
            "file_path": primary_path,
            "format": output_format,
            "images": generated_images,
            "tables": formatted_tables,
            "sections": len(parsed["headings"]),
            "exports": export_results,
            "markdown_path": markdown_path,
        }

    # ------------------------------------------------------------------
    # Parsing helpers
    # ------------------------------------------------------------------

    def _parse_markdown_structure(self, content: str) -> Dict[str, Any]:
        headings = re.findall(r"^(#{1,6})\s+(.+)$", content, re.MULTILINE)
        images = re.findall(r"!\[([^\]]+)\]\(([^\)]+)\)", content)
        table_pattern = r"\|(.+)\|[\r\n]+\|[-:\s|]+\|[\r\n]+((?:\|.+\|[\r\n]+)+)"
        tables = re.findall(table_pattern, content)
        return {"headings": headings, "images": images, "tables": tables}

    # ------------------------------------------------------------------
    # Asset generation
    # ------------------------------------------------------------------

    def _generate_images(self, image_refs: List[tuple], topic: str) -> Tuple[List[Dict[str, str]], Dict[str, str]]:
        generated: List[Dict[str, str]] = []
        replacements: Dict[str, str] = {}

        if not image_refs:
            return generated, replacements

        if not PIL_AVAILABLE:
            print("      ⚠️  Pillow not installed. Install with: pip install Pillow")

        for idx, (caption, path_ref) in enumerate(image_refs, 1):
            safe_topic = re.sub(r"[^\w\s-]", "", topic).strip().replace(" ", "_") or "graive"
            img_filename = f"{safe_topic}_figure_{idx}.png"
            img_path = str(self.images_dir / img_filename)

            print(f"      • Generating image {idx}/{len(image_refs)}: {caption[:50]}...")

            if PIL_AVAILABLE:
                self._create_branded_image(img_path, caption, idx)
                status = "generated"
            else:  # pragma: no cover - dependency missing fallback
                with open(img_path, "wb") as fallback_img:
                    fallback_img.write(MINIMAL_PNG_BYTES)
                status = "fallback"

            replacements[path_ref] = img_path
            generated.append(
                {
                    "caption": caption,
                    "path": img_path,
                    "filename": img_filename,
                    "description": f"Figure {idx}: {caption}",
                    "status": status,
                }
            )

        return generated, replacements

    def _format_tables(self, table_data: List[tuple]) -> List[Dict[str, Any]]:
        formatted = []
        for idx, table in enumerate(table_data, 1):
            print(f"      • Formatting table {idx}/{len(table_data)}...")
            if len(table) >= 2:
                headers = [h.strip() for h in table[0].split("|") if h.strip()]
                rows_text = table[1].strip()
                rows = []
                for row_text in rows_text.split("\n"):
                    row = [cell.strip() for cell in row_text.split("|") if cell.strip()]
                    if row:
                        rows.append(row)

                formatted.append(
                    {
                        "title": f"Table {idx}",
                        "headers": headers,
                        "rows": rows,
                        "index": idx,
                    }
                )
        return formatted

    # ------------------------------------------------------------------
    # Styling + export helpers
    # ------------------------------------------------------------------

    def _apply_styling(
        self,
        content: str,
        parsed: Dict[str, Any],
        image_replacements: Dict[str, str],
    ) -> str:
        styled = content

        for original, new_path in image_replacements.items():
            styled = styled.replace(f"]({original})", f"]({Path(new_path).as_posix()})")

        for level, heading in parsed["headings"]:
            level_num = len(level)
            styled = styled.replace(
                f"{level} {heading}", f"{'#' * level_num} {heading.upper() if level_num == 1 else heading}"
            )

        return styled

    def _export_document(
        self,
        content: str,
        title: str,
        author: str,
        format: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
        include_toc: bool,
        include_page_numbers: bool,
    ) -> Optional[str]:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_title = re.sub(r"[^\w\s-]", "", title).strip().replace(" ", "_") or "document"

        if format == "docx":
            filename = f"{safe_title}_{timestamp}_formatted.docx"
            target_path = str(self.documents_dir / filename)
            return self._build_docx(
                content,
                title,
                author,
                images,
                tables,
                target_path,
                include_toc,
                include_page_numbers,
            )

        if format == "pdf":
            filename = f"{safe_title}_{timestamp}_formatted.pdf"
            target_path = str(self.documents_dir / filename)
            return self._build_pdf(
                content,
                title,
                author,
                images,
                tables,
                target_path,
                include_toc,
                include_page_numbers,
            )

        filename = f"{safe_title}_{timestamp}_formatted.md"
        target_path = str(self.documents_dir / filename)
        self._save_enhanced_markdown(target_path, content, title, author, images, tables)
        return target_path

    def _save_enhanced_markdown(
        self,
        file_path: str,
        content: str,
        title: str,
        author: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
    ) -> None:
        doc_content = f"""---
title: {title}
author: {author}
date: {datetime.now().strftime('%B %d, %Y')}
format: Professional Academic Document
generated_by: Graive AI - PhD-Level Document Generation System
---

# {title}

**Author:** {author}
**Date:** {datetime.now().strftime('%B %d, %Y')}

---

{content}

---

## Document Metadata

**Images:** {len(images)} figures included
**Tables:** {len(tables)} data tables included
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Quality Level:** PhD-Standard Academic Writing

---

*This document was professionally formatted by Graive AI using PhD-level quality standards.*
"""

        with open(file_path, "w", encoding="utf-8") as handle:
            handle.write(doc_content)

    # ------------------------------------------------------------------
    # DOCX rendering
    # ------------------------------------------------------------------

    def _build_docx(
        self,
        content: str,
        title: str,
        author: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
        target_path: str,
        include_toc: bool,
        include_page_numbers: bool,
    ) -> Optional[str]:
        if not DOCX_AVAILABLE:
            return self._build_docx_fallback(
                content,
                title,
                author,
                images,
                tables,
                target_path,
            )

        print("      Creating DOCX deliverable...")
        doc = Document()

        title_para = doc.add_heading(title, level=0)
        title_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

        meta_para = doc.add_paragraph()
        meta_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        meta_run = meta_para.add_run(
            f"Author: {author} | Date: {datetime.now().strftime('%B %d, %Y')}"
        )
        meta_run.italic = True

        doc.add_paragraph()

        if include_toc:
            doc.add_heading("Table of Contents", level=1)
            doc.add_paragraph(
                "(Update fields in Microsoft Word to refresh the table of contents.)",
                style="Intense Quote",
            )
            doc.add_page_break()

        self._render_markdown_to_docx(doc, content, images, tables)

        doc.save(target_path)
        return target_path

    def _build_docx_fallback(
        self,
        content: str,
        title: str,
        author: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
        target_path: str,
    ) -> Optional[str]:
        print("      ⚠️  python-docx not installed. Using HTML-based DOCX fallback.")

        html_document = self._render_html_document(content, title, author, images, tables)
        created = datetime.now().isoformat()

        content_types_xml = """<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Default Extension="html" ContentType="text/html"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
    <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
    <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
</Types>
"""

        rels_xml = """<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
    <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
    <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>
"""

        core_xml = f"""<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <dc:title>{html.escape(title)}</dc:title>
    <dc:creator>{html.escape(author)}</dc:creator>
    <cp:lastModifiedBy>Graive AI</cp:lastModifiedBy>
    <dcterms:created xsi:type="dcterms:W3CDTF">{created}</dcterms:created>
    <dcterms:modified xsi:type="dcterms:W3CDTF">{created}</dcterms:modified>
</cp:coreProperties>
"""

        app_xml = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
    <Application>Graive AI Formatter</Application>
    <DocSecurity>0</DocSecurity>
    <AppVersion>1.0</AppVersion>
</Properties>
"""

        document_xml = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <w:body>
    <w:altChunk r:id="htmlChunk"/>
    <w:sectPr>
      <w:pgSz w:w="12240" w:h="15840"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440" w:header="720" w:footer="720" w:gutter="0"/>
    </w:sectPr>
  </w:body>
</w:document>
"""

        document_rels_xml = """<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="htmlChunk" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/aFChunk" Target="afchunk1.html"/>
</Relationships>
"""

        with zipfile.ZipFile(target_path, "w", zipfile.ZIP_DEFLATED) as archive:
            archive.writestr("[Content_Types].xml", content_types_xml)
            archive.writestr("_rels/.rels", rels_xml)
            archive.writestr("docProps/core.xml", core_xml)
            archive.writestr("docProps/app.xml", app_xml)
            archive.writestr("word/document.xml", document_xml)
            archive.writestr("word/_rels/document.xml.rels", document_rels_xml)
            archive.writestr("word/afchunk1.html", html_document.encode("utf-8"))

        return target_path

    def _render_html_document(
        self,
        content: str,
        title: str,
        author: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
    ) -> str:
        extensions = ["tables", "fenced_code"]
        html_body = md_to_html(content, extensions=extensions if MARKDOWN_AVAILABLE else None)

        for image in images:
            data_uri = self._image_to_data_uri(image.get("path"))
            if data_uri:
                html_body = html_body.replace(Path(image.get("path")).as_posix(), data_uri)

        styles = """
        <style>
            body { font-family: 'Times New Roman', serif; line-height: 1.5; margin: 1.5rem; }
            h1, h2, h3 { color: #1a3d6d; }
            table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
            table, th, td { border: 1px solid #666; padding: 6px; }
            img { max-width: 100%; display: block; margin: 1rem auto; }
            em { font-style: italic; }
            strong { font-weight: bold; }
            blockquote { border-left: 4px solid #1a3d6d; padding-left: 1rem; color: #333; }
        </style>
        """

        header = (
            f"<h1>{html.escape(title)}</h1>"
            f"<p><em>Author: {html.escape(author)}</em><br/>"
            f"<em>Date: {datetime.now().strftime('%B %d, %Y')}</em></p>"
        )

        return (
            "<!DOCTYPE html>\n"
            "<html><head><meta charset=\"utf-8\"/>"
            f"<title>{html.escape(title)}</title>"
            f"{styles}</head><body>"
            f"{header}"
            f"{html_body}"
            "</body></html>"
        )

    def _image_to_data_uri(self, path: Optional[str]) -> Optional[str]:
        if not path:
            return None
        try:
            with open(path, "rb") as image_file:
                encoded = base64.b64encode(image_file.read()).decode("ascii")
        except FileNotFoundError:
            return None
        except Exception as exc:  # pragma: no cover - unexpected decoding issues
            print(f"      ⚠️  Unable to embed image {path}: {exc}")
            return None

        extension = Path(path).suffix.lower().lstrip(".")
        if extension in {"jpg", "jpeg"}:
            mime = "image/jpeg"
        elif extension == "gif":
            mime = "image/gif"
        else:
            mime = "image/png"

        return f"data:{mime};base64,{encoded}"

    def _render_markdown_to_docx(
        self,
        doc: "Document",
        content: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
    ) -> None:
        image_lookup = {Path(img["path"]).as_posix(): img for img in images}
        table_iter = iter(tables)
        lines = content.splitlines()
        i = 0

        while i < len(lines):
            line = lines[i]
            stripped = line.strip()

            if not stripped:
                doc.add_paragraph()
                i += 1
                continue

            if self._is_table_line(stripped) and (i + 1) < len(lines) and self._is_table_divider(lines[i + 1].strip()):
                table_data = next(table_iter, None)
                if table_data:
                    self._insert_docx_table(doc, table_data)

                i += 2
                while i < len(lines) and lines[i].strip().startswith("|"):
                    i += 1
                continue

            img_match = re.match(r"!\[([^\]]*)\]\(([^\)]+)\)", stripped)
            if img_match:
                img_path = Path(img_match.group(2)).as_posix()
                image_data = image_lookup.get(img_path)
                if image_data and Path(image_data["path"]).exists():
                    self._insert_docx_image(doc, image_data)
                i += 1
                continue

            self._insert_markdown_paragraph(doc, line)
            i += 1

        if tables:
            doc.add_page_break()
            doc.add_heading("Data Tables", level=1)
            for table in tables:
                self._insert_docx_table(doc, table)

        if images:
            doc.add_page_break()
            doc.add_heading("Figures", level=1)
            for image in images:
                if Path(image["path"]).exists():
                    self._insert_docx_image(doc, image)

    @staticmethod
    def _is_table_line(line: str) -> bool:
        return line.startswith("|") and line.endswith("|")

    @staticmethod
    def _is_table_divider(line: str) -> bool:
        return set(line) <= {"|", "-", ":", " "}

    def _insert_markdown_paragraph(self, doc: "Document", line: str) -> None:
        stripped = line.strip()

        heading_match = re.match(r"^(#{1,6})\s+(.*)$", stripped)
        if heading_match:
            level = len(heading_match.group(1))
            text = heading_match.group(2)
            doc.add_heading(text, level=min(level, 4))
            return

        if re.match(r"^>\s+", stripped):
            doc.add_paragraph(stripped[2:], style="Intense Quote")
            return

        list_match = re.match(r"^(\s*)([-*+])\s+(.*)$", line)
        if list_match:
            _, _, text = list_match.groups()
            paragraph = doc.add_paragraph(style="List Bullet")
            self._apply_inline_markdown(paragraph, text)
            return

        numbered_match = re.match(r"^(\s*)\d+\.\s+(.*)$", line)
        if numbered_match:
            paragraph = doc.add_paragraph(style="List Number")
            self._apply_inline_markdown(paragraph, numbered_match.group(2))
            return

        paragraph = doc.add_paragraph()
        self._apply_inline_markdown(paragraph, stripped)

    def _apply_inline_markdown(self, paragraph, text: str) -> None:
        if not text:
            return

        token_pattern = re.compile(
            r"(\*\*\*[^*]+\*\*\*|\*\*[^*]+\*\*|\*[^*]+\*|`[^`]+`|~~[^~]+~~)"
        )
        last_end = 0

        for match in token_pattern.finditer(text):
            if match.start() > last_end:
                paragraph.add_run(text[last_end : match.start()])

            token = match.group(0)
            clean = token.strip("*`~")
            run = paragraph.add_run(clean)

            if token.startswith("***"):
                run.bold = True
                run.italic = True
            elif token.startswith("**"):
                run.bold = True
            elif token.startswith("*"):
                run.italic = True
            elif token.startswith("~~"):
                run.font.strike = True
            elif token.startswith("`"):
                run.font.name = "Courier New"

            last_end = match.end()

        if last_end < len(text):
            paragraph.add_run(text[last_end:])

    def _insert_docx_image(self, doc: "Document", image: Dict[str, Any]) -> None:
        doc.add_paragraph()
        figure_para = doc.add_paragraph()
        figure_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = figure_para.add_run()
        try:
            run.add_picture(image["path"], width=Inches(6))
        except Exception as exc:  # pragma: no cover - image decoding edge cases
            figure_para.add_run(f"[Image unavailable: {exc}]")
            return

        caption_para = doc.add_paragraph(image["description"], style="Caption")
        caption_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

    def _insert_docx_table(self, doc: "Document", table: Dict[str, Any]) -> None:
        doc.add_paragraph()
        doc.add_paragraph(table.get("title", "Table"), style="Heading 3")

        headers = table.get("headers", [])
        rows = table.get("rows", [])
        cols = len(headers) if headers else max((len(row) for row in rows), default=1)

        table_obj = doc.add_table(rows=1, cols=max(cols, 1))
        hdr_cells = table_obj.rows[0].cells
        for idx, header in enumerate(headers):
            hdr_cells[idx].text = header

        for row in rows:
            row_cells = table_obj.add_row().cells
            for idx, cell in enumerate(row):
                if idx < len(row_cells):
                    row_cells[idx].text = cell

        if table.get("caption"):
            caption = doc.add_paragraph(table["caption"], style="Caption")
            caption.alignment = WD_ALIGN_PARAGRAPH.CENTER

    # ------------------------------------------------------------------
    # PDF rendering
    # ------------------------------------------------------------------

    def _build_pdf(
        self,
        content: str,
        title: str,
        author: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
        target_path: str,
        include_toc: bool,
        include_page_numbers: bool,
    ) -> Optional[str]:
        if not PDF_AVAILABLE:
            return self._build_pdf_fallback(
                content,
                title,
                author,
                images,
                tables,
                target_path,
            )

        print("      Creating PDF deliverable...")
        pdf = _PDFDocument()
        pdf.set_auto_page_break(auto=True, margin=15)
        pdf.add_page()
        pdf.set_title(title)
        pdf.set_author(author)

        pdf.set_font("Helvetica", "B", 18)
        pdf.cell(0, 10, title, ln=True, align="C")
        pdf.set_font("Helvetica", "I", 12)
        pdf.cell(0, 8, f"Author: {author}", ln=True, align="C")
        pdf.cell(0, 8, f"Date: {datetime.now().strftime('%B %d, %Y')}", ln=True, align="C")
        pdf.ln(10)

        extensions = ["tables", "fenced_code"]
        if include_toc:
            extensions.append("toc")
        if not MARKDOWN_AVAILABLE:
            print("      ⚠️  markdown package not installed. Install with: pip install markdown")
        html_content = md_to_html(content, extensions=extensions)
        pdf.write_html(html_content)

        if include_page_numbers:
            pdf.alias_nb_pages()

        pdf.output(target_path)
        return target_path

    # ------------------------------------------------------------------
    # Image helpers
    # ------------------------------------------------------------------

    def _build_pdf_fallback(
        self,
        content: str,
        title: str,
        author: str,
        images: List[Dict[str, Any]],
        tables: List[Dict[str, Any]],
        target_path: str,
    ) -> Optional[str]:
        print("      ⚠️  fpdf2 not installed. Using minimalist PDF fallback.")

        builder = self._SimplePDFBuilder(title=title, author=author)
        header_lines = [
            title.upper(),
            f"Author: {author}",
            f"Date: {datetime.now().strftime('%B %d, %Y')}",
            "",
        ]
        text_lines = header_lines + self._markdown_to_plaintext(content)
        builder.add_text_lines(text_lines)

        for image in images:
            builder.add_image(image.get("path"), self._parse_png_for_pdf)

        builder.write(target_path)
        return target_path

    def _markdown_to_plaintext(self, content: str) -> List[str]:
        lines: List[str] = []
        for raw_line in content.splitlines():
            stripped = raw_line.strip()
            if not stripped:
                lines.append("")
                continue

            if stripped.startswith("|") and "|" in stripped:
                lines.append(stripped)
                continue

            if stripped.startswith("#"):
                text = stripped.lstrip("#").strip().upper()
                lines.extend(self._wrap_text(text))
                continue

            if re.match(r"^>\s+", stripped):
                quote_text = stripped.lstrip(">").strip()
                lines.extend(self._wrap_text(f"Quote: {quote_text}"))
                continue

            bullet_match = re.match(r"^(\s*[-*+])\s+(.*)$", raw_line)
            if bullet_match:
                text = f"• {bullet_match.group(2).strip()}"
            else:
                text = stripped

            text = re.sub(r"\*\*([^*]+)\*\*", r"\1", text)
            text = re.sub(r"\*([^*]+)\*", r"\1", text)
            text = re.sub(r"`([^`]+)`", r"\1", text)

            lines.extend(self._wrap_text(text))

        return lines

    def _wrap_text(self, text: str, width: int = 90) -> List[str]:
        if not text:
            return [""]

        words = text.split()
        if not words:
            return [text]

        wrapped: List[str] = []
        current = words[0]
        for word in words[1:]:
            if len(current) + 1 + len(word) <= width:
                current += f" {word}"
            else:
                wrapped.append(current)
                current = word
        wrapped.append(current)
        return wrapped

    def _parse_png_for_pdf(self, path: Optional[str]) -> Optional[Dict[str, Any]]:
        if not path:
            return None
        try:
            with open(path, "rb") as fh:
                data = fh.read()
        except FileNotFoundError:
            return None
        except Exception:
            return None

        if not data.startswith(PNG_SIGNATURE):
            return None

        offset = len(PNG_SIGNATURE)
        width = height = bit_depth = color_type = None
        idat_chunks = bytearray()

        while offset < len(data):
            if offset + 8 > len(data):
                break
            length = int.from_bytes(data[offset:offset + 4], "big")
            offset += 4
            chunk_type = data[offset:offset + 4]
            offset += 4
            chunk_data = data[offset:offset + length]
            offset += length
            offset += 4  # CRC

            if chunk_type == b"IHDR":
                width = int.from_bytes(chunk_data[0:4], "big")
                height = int.from_bytes(chunk_data[4:8], "big")
                bit_depth = chunk_data[8]
                color_type = chunk_data[9]
            elif chunk_type == b"IDAT":
                idat_chunks.extend(chunk_data)
            elif chunk_type == b"IEND":
                break

        if None in (width, height, bit_depth, color_type):
            return None

        if bit_depth != 8:
            return None

        try:
            raw = zlib.decompress(bytes(idat_chunks))
        except Exception:
            return None

        channel_counts = {0: 1, 2: 3, 4: 2, 6: 4}
        channels = channel_counts.get(color_type)
        if channels is None:
            return None

        decoded = self._decode_png_scanlines(raw, width, height, channels)

        if color_type == 6:  # RGBA -> RGB
            rgb = bytearray()
            for i in range(0, len(decoded), 4):
                rgb.extend(decoded[i:i + 3])
            decoded = bytes(rgb)
            color_space = "/DeviceRGB"
        elif color_type == 4:  # grayscale + alpha -> grayscale
            gray = bytearray()
            for i in range(0, len(decoded), 2):
                gray.append(decoded[i])
            decoded = bytes(gray)
            color_space = "/DeviceGray"
        elif color_type == 0:
            color_space = "/DeviceGray"
        else:
            color_space = "/DeviceRGB"

        compressed = zlib.compress(decoded)
        return {
            "width": width,
            "height": height,
            "color_space": color_space,
            "bits": bit_depth,
            "data": compressed,
        }

    def _decode_png_scanlines(
        self,
        data: bytes,
        width: int,
        height: int,
        channels: int,
    ) -> bytes:
        stride = width * channels
        result = bytearray(height * stride)
        pos = 0
        prev_row = bytearray(stride)
        bytes_per_pixel = channels

        for row in range(height):
            filter_type = data[pos]
            pos += 1
            row_bytes = bytearray(data[pos:pos + stride])
            pos += stride

            if filter_type == 0:  # None
                pass
            elif filter_type == 1:  # Sub
                for i in range(stride):
                    left = row_bytes[i - bytes_per_pixel] if i >= bytes_per_pixel else 0
                    row_bytes[i] = (row_bytes[i] + left) & 0xFF
            elif filter_type == 2:  # Up
                for i in range(stride):
                    row_bytes[i] = (row_bytes[i] + prev_row[i]) & 0xFF
            elif filter_type == 3:  # Average
                for i in range(stride):
                    left = row_bytes[i - bytes_per_pixel] if i >= bytes_per_pixel else 0
                    up = prev_row[i]
                    row_bytes[i] = (row_bytes[i] + ((left + up) // 2)) & 0xFF
            elif filter_type == 4:  # Paeth
                for i in range(stride):
                    left = row_bytes[i - bytes_per_pixel] if i >= bytes_per_pixel else 0
                    up = prev_row[i]
                    up_left = prev_row[i - bytes_per_pixel] if i >= bytes_per_pixel else 0
                    row_bytes[i] = (row_bytes[i] + self._paeth_predictor(left, up, up_left)) & 0xFF
            else:
                raise ValueError(f"Unsupported PNG filter type: {filter_type}")

            start = row * stride
            result[start:start + stride] = row_bytes
            prev_row = row_bytes

        return bytes(result)

    @staticmethod
    def _paeth_predictor(a: int, b: int, c: int) -> int:
        p = a + b - c
        pa = abs(p - a)
        pb = abs(p - b)
        pc = abs(p - c)
        if pa <= pb and pa <= pc:
            return a
        if pb <= pc:
            return b
        return c

    class _SimplePDFBuilder:
        PAGE_WIDTH = 595
        PAGE_HEIGHT = 842
        MARGIN = 72
        LINE_HEIGHT = 16

        def __init__(self, title: str, author: str):
            self.title = title
            self.author = author
            self.pages: List[Dict[str, Any]] = [{"text": [], "images": []}]
            self.image_data: List[Dict[str, Any]] = []

        def add_text_lines(self, lines: List[str]) -> None:
            page = self.pages[-1]
            for line in lines:
                if len(page["text"]) >= self._max_lines():
                    page = {"text": [], "images": []}
                    self.pages.append(page)
                page["text"].append(line)

        def add_image(self, path: Optional[str], parser) -> None:
            if not path:
                return
            info = parser(path)
            if not info:
                return
            index = len(self.image_data)
            self.image_data.append(info)
            self.pages.append({"text": [], "images": [index]})

        def write(self, target_path: str) -> None:
            objects: Dict[int, bytes] = {}
            next_id = 1

            def reserve() -> int:
                nonlocal next_id
                oid = next_id
                next_id += 1
                return oid

            def set_object(obj_id: int, content: bytes) -> None:
                objects[obj_id] = content

            font_obj = reserve()
            set_object(font_obj, b"<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>")

            image_obj_ids: List[int] = []
            for image in self.image_data:
                obj_id = reserve()
                image_obj_ids.append(obj_id)
                dict_entries = (
                    f"/Type /XObject /Subtype /Image /Width {image['width']} /Height {image['height']} "
                    f"/ColorSpace {image['color_space']} /BitsPerComponent {image['bits']} /Filter /FlateDecode"
                )
                set_object(obj_id, self._stream_object(dict_entries, image["data"]))

            content_obj_ids: List[int] = []
            page_obj_ids: List[int] = []
            for _ in self.pages:
                content_obj_ids.append(reserve())
                page_obj_ids.append(reserve())

            pages_obj_id = reserve()
            catalog_obj_id = reserve()

            image_names = {idx: f"Im{idx + 1}" for idx in range(len(self.image_data))}

            for idx, page in enumerate(self.pages):
                stream = self._build_page_stream(page, image_names)
                set_object(content_obj_ids[idx], self._stream_object("", stream))

            for idx, page in enumerate(self.pages):
                resources_parts = [f"/Font << /F1 {font_obj} 0 R >>"]
                if page["images"]:
                    xobject_entries = " ".join(
                        f"/{image_names[image_index]} {image_obj_ids[image_index]} 0 R" for image_index in page["images"]
                    )
                    resources_parts.append(f"/XObject << {xobject_entries} >>")
                resources = "<< " + " ".join(resources_parts) + " >>"

                page_dict = (
                    f"<< /Type /Page /Parent {pages_obj_id} 0 R "
                    f"/MediaBox [0 0 {self.PAGE_WIDTH} {self.PAGE_HEIGHT}] "
                    f"/Resources {resources} /Contents {content_obj_ids[idx]} 0 R >>"
                )
                set_object(page_obj_ids[idx], page_dict.encode("latin-1"))

            kids = " ".join(f"{obj_id} 0 R" for obj_id in page_obj_ids)
            pages_dict = f"<< /Type /Pages /Count {len(page_obj_ids)} /Kids [{kids}] >>"
            set_object(pages_obj_id, pages_dict.encode("latin-1"))

            catalog_dict = f"<< /Type /Catalog /Pages {pages_obj_id} 0 R >>"
            set_object(catalog_obj_id, catalog_dict.encode("latin-1"))

            self._write_pdf(target_path, objects, catalog_obj_id)

        def _max_lines(self) -> int:
            usable_height = self.PAGE_HEIGHT - 2 * self.MARGIN
            return max(1, int(usable_height // self.LINE_HEIGHT))

        def _build_page_stream(self, page: Dict[str, Any], image_names: Dict[int, str]) -> bytes:
            commands: List[str] = []

            if page["text"]:
                commands.append("BT")
                commands.append("/F1 12 Tf")
                commands.append(f"{self.LINE_HEIGHT} TL")
                start_y = self.PAGE_HEIGHT - self.MARGIN
                commands.append(f"72 {start_y} Td")
                first_line = True
                for line in page["text"]:
                    escaped = self._pdf_escape(line)
                    if not first_line:
                        commands.append("T*")
                    commands.append(f"({escaped}) Tj")
                    first_line = False
                commands.append("ET")

            for image_index in page["images"]:
                image = self.image_data[image_index]
                name = image_names[image_index]
                max_width = self.PAGE_WIDTH - 2 * self.MARGIN
                scale = min(1.0, max_width / max(image["width"], 1))
                width = image["width"] * scale
                height = image["height"] * scale
                x = (self.PAGE_WIDTH - width) / 2
                y = self.MARGIN
                commands.append("q")
                commands.append(f"{width:.2f} 0 0 {height:.2f} {x:.2f} {self.PAGE_HEIGHT - y - height:.2f} cm")
                commands.append(f"/{name} Do")
                commands.append("Q")

            return "\n".join(commands).encode("latin-1")

        def _stream_object(self, dict_entries: str, data: bytes) -> bytes:
            prefix = f"<< {dict_entries} " if dict_entries else "<< "
            header = f"{prefix}/Length {len(data)} >>\nstream\n".encode("latin-1")
            footer = b"\nendstream"
            return header + data + footer

        def _pdf_escape(self, text: str) -> str:
            text = text.replace("\\", "\\\\")
            text = text.replace("(", "\\(")
            text = text.replace(")", "\\)")
            return text

        def _write_pdf(self, target_path: str, objects: Dict[int, bytes], catalog_obj_id: int) -> None:
            sorted_ids = sorted(objects.keys())
            offsets: Dict[int, int] = {}

            with open(target_path, "wb") as handle:
                handle.write(b"%PDF-1.4\n")

                for obj_id in sorted_ids:
                    offsets[obj_id] = handle.tell()
                    handle.write(f"{obj_id} 0 obj\n".encode("latin-1"))
                    handle.write(objects[obj_id])
                    handle.write(b"\nendobj\n")

                xref_pos = handle.tell()
                handle.write(f"xref\n0 {len(sorted_ids) + 1}\n".encode("latin-1"))
                handle.write(b"0000000000 65535 f \n")
                for obj_id in sorted_ids:
                    handle.write(f"{offsets[obj_id]:010} 00000 n \n".encode("latin-1"))

                handle.write(b"trailer\n")
                handle.write(f"<< /Size {len(sorted_ids) + 1} /Root {catalog_obj_id} 0 R >>\n".encode("latin-1"))
                handle.write(b"startxref\n")
                handle.write(f"{xref_pos}\n".encode("latin-1"))
                handle.write(b"%%EOF")

    def _create_branded_image(self, path: str, caption: str, index: int) -> None:
        image = Image.new("RGB", (1200, 720), color=(12, 22, 36))
        draw = ImageDraw.Draw(image)

        border_color = (32 + (index * 17) % 140, 96, 168)
        draw.rectangle([(40, 40), (1160, 680)], outline=border_color, width=6)

        header_text = f"Figure {index}"
        wrapped_caption = textwrap.fill(caption, width=38)

        try:
            title_font = ImageFont.truetype("arial.ttf", 48)
            body_font = ImageFont.truetype("arial.ttf", 30)
        except Exception:  # pragma: no cover - font availability varies
            title_font = ImageFont.load_default()
            body_font = ImageFont.load_default()

        title_w, _ = draw.textsize(header_text, font=title_font)
        draw.text(((1200 - title_w) / 2, 120), header_text, fill=(255, 255, 255), font=title_font)

        draw.multiline_text(
            (120, 240),
            wrapped_caption,
            fill=(225, 235, 245),
            font=body_font,
            spacing=12,
        )

        footer_text = "Generated by Graive AI"
        footer_w, _ = draw.textsize(footer_text, font=body_font)
        draw.text(((1200 - footer_w) / 2, 640), footer_text, fill=(180, 190, 210), font=body_font)

        image.save(path)


def create_document_formatter(workspace_path: str) -> ProfessionalDocumentFormatter:
    """Factory function to create the professional formatter."""

    return ProfessionalDocumentFormatter(workspace_path)
